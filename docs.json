[{"name":"Snapshot","comment":" Snapshot testing framework for Elm.\n\nAn idiomatic Elm API for approval/snapshot testing.\n\n    -- String output (most common)\n    Snapshot.test \"greeting\" <|\n        \\() -> greet \"World\"\n\n    -- JSON output with pretty printing\n    Snapshot.json \"user data\" <|\n        \\() -> User.encode user\n\n    -- With scrubbers for non-deterministic output\n    Snapshot.test \"log entry\" (\\() -> formatLog entry)\n        |> Snapshot.withScrubbers [ Scrubber.timestamp ]\n\n    -- Grouped tests\n    Snapshot.describe \"Date formatting\"\n        [ Snapshot.test \"ISO format\" <| \\() -> Date.toIso date\n        , Snapshot.test \"human readable\" <| \\() -> Date.toHuman date\n        ]\n\n    -- Custom printer\n    Snapshot.custom myPrinter \"custom format\" <|\n        \\() -> myValue\n\n    -- Checked test (fails early if Err)\n    Snapshot.checkedTest \"parsed config\" <|\n        \\() ->\n            Config.parse rawInput\n                |> Result.map Config.toString\n\n    -- Focus on specific tests during development\n    Snapshot.only <|\n        Snapshot.test \"work in progress\" <|\n            \\() -> newFeature\n\n    -- Skip tests temporarily\n    Snapshot.skip <|\n        Snapshot.test \"broken test\" <|\n            \\() -> brokenCode\n\n    -- Placeholder for tests to implement later\n    Snapshot.todo \"implement edge case handling\"\n\n@docs Test, run, test, json, custom, checkedTest, checkedJson, checkedCustom, taskTest, taskJson, taskCustom, withScrubbers, describe, only, skip, todo\n\n","unions":[{"name":"Test","comment":" An opaque type representing a snapshot test or group of tests.\n\nCreate tests using `test`, `json`, `custom`, or their `task*` variants.\nGroup related tests using `describe`.\n\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"checkedCustom","comment":" Create a snapshot test with a custom printer that validates before snapshotting.\n\n    Snapshot.checkedCustom xmlPrinter \"parsed xml\" <|\n        \\() ->\n            Xml.parse rawXml\n                |> Result.mapError Xml.errorToString\n\n","type":"Snapshot.Printer.Printer a -> String.String -> (() -> Result.Result String.String a) -> Snapshot.Test"},{"name":"checkedJson","comment":" Create a JSON snapshot test that validates before snapshotting.\n\n    Snapshot.checkedJson \"decoded user\" <|\n        \\() ->\n            Json.Decode.decodeString userDecoder jsonString\n                |> Result.mapError Json.Decode.errorToString\n\n","type":"String.String -> (() -> Result.Result String.String Json.Encode.Value) -> Snapshot.Test"},{"name":"checkedTest","comment":" Create a snapshot test that validates before snapshotting.\n\n    Snapshot.checkedTest \"parsed config\" <|\n        \\() ->\n            Config.parse rawInput\n                |> Result.map Config.toString\n\nIf the Result is `Err`, the test fails with that error message and no\nsnapshot is written. If `Ok`, the value is snapshotted normally.\n\nThis is useful when test setup might fail (parsing, validation, etc.)\nand you want to catch those failures before snapshotting.\n\n","type":"String.String -> (() -> Result.Result String.String String.String) -> Snapshot.Test"},{"name":"custom","comment":" Create a snapshot test with a custom printer.\n\n    Snapshot.custom myXmlPrinter \"config file\" <|\n        \\() ->\n            buildConfig options\n\nUse this when you need a custom `a -> String` conversion.\n\n","type":"Snapshot.Printer.Printer a -> String.String -> (() -> a) -> Snapshot.Test"},{"name":"describe","comment":" Group related tests together.\n\n    Snapshot.describe \"Date formatting\"\n        [ Snapshot.test \"ISO format\" <|\n            \\() -> Date.toIsoString date\n        , Snapshot.test \"human readable\" <|\n            \\() -> Date.toHumanString date\n        ]\n\nTest names are prefixed with the group name, separated by \" / \".\nSnapshot files are stored in subdirectories matching the group structure.\n\n","type":"String.String -> List.List Snapshot.Test -> Snapshot.Test"},{"name":"json","comment":" Create a snapshot test for JSON values with pretty printing.\n\n    Snapshot.json \"user data\" <|\n        \\() ->\n            User.encode user\n\nUses 2-space indentation. Keys are sorted alphabetically for deterministic output.\n\n","type":"String.String -> (() -> Json.Encode.Value) -> Snapshot.Test"},{"name":"only","comment":" Run only this test (and any other tests marked with `only`).\n\n    Snapshot.only <|\n        Snapshot.test \"focus on this\" <|\n            \\() -> workInProgress\n\nWhen any test is marked with `only`, all tests without `only` will be skipped.\nUse this during development to focus on specific tests.\n\nNote: `skip` takes precedence over `only` - a skipped test won't run even\nif it's inside an `only` block.\n\n","type":"Snapshot.Test -> Snapshot.Test"},{"name":"run","comment":" Run a list of snapshot tests as an elm-pages Script.\n\n    -- In your Snapshots.elm script:\n    run : Script\n    run =\n        Snapshot.run \"Snapshots\"\n            [ Snapshot.test \"greeting\" <| \\() -> greet \"World\"\n            , Snapshot.json \"config\" <| \\() -> encodeConfig config\n            ]\n\nThe first argument is the script name (typically matching the module name).\nThis organizes snapshots into `snapshots/<ScriptName>/` directories,\nallowing multiple snapshot scripts in the same project.\n\nSupports CLI options:\n\n  - `--approve` - Approve all new/changed snapshots\n  - `--approve-only \"test name\"` - Approve a specific test\n  - `--ci` - Compact output for CI environments\n  - `--list` - List all test names without running\n  - `--prune` - Remove obsolete snapshot files\n  - `--reporter <tool>` - Open diff tool for failures (code, opendiff, meld, ksdiff, kdiff3, diff, or any command)\n\n","type":"String.String -> List.List Snapshot.Test -> Pages.Script.Script"},{"name":"skip","comment":" Skip this test.\n\n    Snapshot.skip <|\n        Snapshot.test \"broken test\" <|\n            \\() -> brokenCode\n\nThe test will be reported as skipped but won't be executed.\nUse this to temporarily disable tests without deleting them.\n\nNote: `skip` takes precedence over `only` - a skipped test won't run even\nif it's inside an `only` block.\n\n","type":"Snapshot.Test -> Snapshot.Test"},{"name":"taskCustom","comment":" Create a BackendTask-powered snapshot test with a custom printer.\n\n    Snapshot.taskCustom myPrinter \"fetched data\" <|\n        fetchData\n            |> BackendTask.allowFatal\n\n","type":"Snapshot.Printer.Printer a -> String.String -> BackendTask.BackendTask FatalError.FatalError a -> Snapshot.Test"},{"name":"taskJson","comment":" Create a BackendTask-powered snapshot test for JSON values.\n\n    Snapshot.taskJson \"api response\" <|\n        Http.get url decoder\n            |> BackendTask.allowFatal\n\nUses 2-space indentation. Keys are sorted alphabetically for deterministic output.\n\n","type":"String.String -> BackendTask.BackendTask FatalError.FatalError Json.Encode.Value -> Snapshot.Test"},{"name":"taskTest","comment":" Create a BackendTask-powered snapshot test for string output.\n\n    Snapshot.taskTest \"elm.json deps\" <|\n        File.rawFile \"elm.json\"\n            |> BackendTask.allowFatal\n\nUse this for tests that need IO (file reading, HTTP, etc).\n\n","type":"String.String -> BackendTask.BackendTask FatalError.FatalError String.String -> Snapshot.Test"},{"name":"test","comment":" Create a snapshot test that compares string output.\n\n    Snapshot.test \"greeting\" <|\n        \\() ->\n            greet \"World\"\n\nThis is the most common form - use when your function already returns a String.\n\n","type":"String.String -> (() -> String.String) -> Snapshot.Test"},{"name":"todo","comment":" A placeholder for a test you intend to write later.\n\n    Snapshot.todo \"handle edge case where input is empty\"\n\nThe test will be reported as a todo item. This is useful for jotting down\ntest ideas without implementing them immediately.\n\n","type":"String.String -> Snapshot.Test"},{"name":"withScrubbers","comment":" Add scrubbers to a test for non-deterministic output.\n\n    Snapshot.test \"log entry\" (\\() -> formatLog entry)\n        |> Snapshot.withScrubbers [ Scrubber.timestamp ]\n\n    Snapshot.json \"api response\" (\\() -> encodeResponse resp)\n        |> Snapshot.withScrubbers [ Scrubber.guid, Scrubber.timestamp ]\n\nScrubbers run after printing, replacing patterns like timestamps\nand GUIDs with stable placeholders.\n\n","type":"List.List Snapshot.Scrubber.Scrubber -> Snapshot.Test -> Snapshot.Test"}],"binops":[]},{"name":"Snapshot.Printer","comment":" Printers convert domain objects to strings for snapshot comparison.\n\nEvery snapshot test has a printer (even if it's just identity).\nThe printer's job is to create a human-readable, diffable representation.\n\n**Best practices (Emily Bache):**\n\n  - Keep lines short for easy diff viewing\n  - JSON can be tricky - prefer pretty-printing\n  - Include inputs in output for context\n  - Change printers in separate commits from logic changes\n\n\n# Definition\n\n@docs Printer\n\n\n# Common Printers\n\n@docs string, json, elm\n\n\n# Customization\n\n@docs withExtension\n\n","unions":[],"aliases":[{"name":"Printer","comment":" A printer converts a value of type `a` to a String and specifies\nthe file extension for syntax highlighting in diff tools.\n\nThe extension is used to generate snapshot filenames like:\n\n    test_name.approved.json\n    test_name.received.txt\n\n","args":["a"],"type":"{ extension : String.String, print : a -> String.String }"}],"values":[{"name":"elm","comment":" Pretty-prints any Elm value using elm-format style.\n\nSince published packages cannot use `Debug.toString` directly, you must pass\nit in as the first argument:\n\n    Snapshot.custom (Printer.elm Debug.toString) \"user model\" <|\n        \\() -> model.user\n\nThe output is formatted as valid Elm syntax, making diffs easy to read.\n\nProduces `.elm` files for syntax highlighting in diff tools.\n\n**Dependencies:** This printer relies on `kraklin/elm-debug-parser` and\n`lue-bird/elm-syntax-format` to parse and format the debug output.\n\n","type":"(a -> String.String) -> Snapshot.Printer.Printer a"},{"name":"json","comment":" JSON pretty-printer with sorted keys and 2-space indentation.\n\n    Snapshot.json \"user data\" <|\n        \\() -> User.encode user\n\n**Keys are sorted alphabetically** at all nesting levels for deterministic\noutput. This matches the behavior of Go's `json.Marshal` and Jest's\n`pretty-format` - the modern consensus for testing tools.\n\nUses 2-space indentation, which is the most common convention for JSON\nand produces readable diffs with reasonable line lengths.\n\nProduces `.json` files for syntax highlighting in diff tools.\n\n","type":"Snapshot.Printer.Printer Json.Encode.Value"},{"name":"string","comment":" Identity printer for string output.\n\n    Snapshot.custom Printer.string \"log output\" <|\n        \\() -> formatLog entry\n\nProduces `.txt` files by default.\n\n","type":"Snapshot.Printer.Printer String.String"},{"name":"withExtension","comment":" Change the file extension of a printer.\n\n    xmlPrinter : Printer String\n    xmlPrinter =\n        Printer.string\n            |> Printer.withExtension \"xml\"\n\nUseful when the content type doesn't match the default extension.\n\n","type":"String.String -> Snapshot.Printer.Printer a -> Snapshot.Printer.Printer a"}],"binops":[]},{"name":"Snapshot.Scrubber","comment":" Scrubbers clean non-deterministic content from snapshot output.\n\n\"Fundamentally, a scrubber is a function that takes a string and returns a string.\"\nâ€” [ApprovalTests documentation](https://approvaltests.com/docs/reference/Scrubbers/)\n\nScrubbers are applied AFTER the printer converts your value to a string.\nThey replace variable content (timestamps, GUIDs, etc.) with stable placeholders.\n\n\n# Definition\n\n@docs Scrubber\n\n\n# Built-in Scrubbers\n\n@docs timestamp, guid\n\n\n# Custom Scrubbers\n\n@docs custom, regex, all\n\n","unions":[],"aliases":[{"name":"Scrubber","comment":" A scrubber transforms a string, typically replacing non-deterministic\ncontent with stable placeholders.\n","args":[],"type":"String.String -> String.String"}],"values":[{"name":"all","comment":" Compose multiple scrubbers into one. Applied left to right.\n\n    Scrubber.all\n        [ Scrubber.timestamp\n        , Scrubber.guid\n        , Scrubber.regex \"v\\\\d+\\\\.\\\\d+\\\\.\\\\d+\" \"[VERSION]\"\n        ]\n\n","type":"List.List Snapshot.Scrubber.Scrubber -> String.String -> String.String"},{"name":"custom","comment":" Create a custom scrubber from any String -> String function.\n\n    myCustomScrubber : Scrubber\n    myCustomScrubber =\n        Scrubber.custom (String.replace \"secret\" \"[REDACTED]\")\n\n","type":"(String.String -> String.String) -> Snapshot.Scrubber.Scrubber"},{"name":"guid","comment":" Replace GUIDs/UUIDs with stable placeholders like `[GUID-1]`, `[GUID-2]`.\n\nPreserves referential equality: the same GUID appearing multiple times\nin the output will get the same placeholder number.\n\nMatches standard UUID format: `xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx`\n\n","type":"String.String -> String.String"},{"name":"regex","comment":" Replace all matches of a regex pattern with a fixed string.\n\n    -- Replace version numbers\n    Scrubber.regex \"v\\\\d+\\\\.\\\\d+\\\\.\\\\d+\" \"[VERSION]\"\n\n    -- Replace port numbers\n    Scrubber.regex \":\\\\d{4,5}\" \":[PORT]\"\n\nNote: Uses Elm's Regex module. Invalid patterns are silently ignored.\n\n","type":"String.String -> String.String -> String.String -> String.String"},{"name":"timestamp","comment":" Replace ISO 8601 timestamps with `[TIMESTAMP]`.\n\nMatches patterns like:\n\n  - `2024-01-15T10:30:00Z`\n  - `2024-01-15T10:30:00.123Z`\n  - `2024-01-15T10:30:00+05:00`\n  - `2024-01-15 10:30:00`\n\n","type":"String.String -> String.String"}],"binops":[]}]